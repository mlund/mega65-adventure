/*
 * IRQ example using module level assembly
 *
 * - This is first attempt; for a leaner version see `raster-interrupt2.cpp`
 * - BASIC and KERNAL are spared.
 * - Adapted to LLVM-MOS C++ from "Introduction to Raster IRQs" at Codebase64:
 *   https://codebase64.org/doku.php?id=base:introduction_to_raster_irqs
 *
 * Wombat, 2022
 */
#include <cstdint>

#define PEEK(address) (*(uint8_t*)(address))
#define POKE(address, value) *(uint8_t*)(address) = (value)

extern "C" void do_irq(char raster_line);

/**
 * @brief Initialize interrupts and point to irq() function that is defined in C++
 * 
 * See more here at codebase64:
 * https://codebase64.org/doku.php?id=base:introduction_to_raster_irqs
 */
asm (R"(
.global do_irq
do_irq:
    sei        ;disable maskable IRQs
    lda #$7f
    sta $dc0d  ;disable timer interrupts which can be generated by the two CIA chips
    sta $dd0d  ;the kernal uses such an interrupt to flash the cursor and scan the keyboard, so we better
               ;stop it.
    lda $dc0d  ;by reading this two registers we negate any pending CIA irqs.
    lda $dd0d  ;if we don't do this, a pending CIA irq might occur after we finish setting up our irq.
               ;we don't want that to happen.

    lda #$01   ;this is how to tell the VICII to generate a raster interrupt
    sta $d01a

    lda 240    ;this is how to tell at which rasterline we want the irq to be triggered
    sta $d012
    lda #$1b   ;as there are more than 256 rasterlines, the topmost bit of $d011 serves as
    sta $d011  ;the 9th bit for the rasterline we want our irq to be triggered.
               ;here we simply set up a character screen, leaving the topmost bit 0.

    #lda #$35  ;we turn off the BASIC and KERNAL rom here
    #sta $01   ;the cpu now sees RAM everywhere except at $d000-$e000, where still the registers of
               ;SID/VICII/etc are visible

    lda #<IRQ  ;set interrupt vectors, pointing to interrupt service routine below
    sta $0314
    lda #>IRQ
    sta $0315
    cli        ;clear interrupt flag, allowing the CPU to respond to interrupt requests
    rts
)");

/**
 * @brief Called at every time the raster interrupt is triggered
 */
void called_every_frame()
{
    POKE(0xd020, 2);
    for (int i=0; i < 0x80; i++) {
        asm volatile("nop");
    }
    POKE(0xd020, 0);
}

/**
 * @brief Wrapper function to ensure correct exit from irq
 */
void irq() asm("IRQ");
void irq() {
    called_every_frame();
    asm volatile(R"(
        lsr $d019  ; acknowledge the interrupt by clearing the VIC's interrupt flag
        jmp $ea31  ; jump into KERNAL's standard interrupt service routine
    )");
}

int main() {
    do_irq(240);
    return 0;
}
